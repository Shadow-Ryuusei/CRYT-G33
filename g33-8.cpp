#include <bits/stdc++.h>
#include <strstream>
#include <cryptopp/integer.h>
#include <cryptopp/osrng.h>
#include <cryptopp/nbtheory.h>
#include <cryptopp/hrtimer.h>
#include <cryptopp/sha.h>
#include <cryptopp/filters.h>
#include <cryptopp/hex.h>

using namespace std;
using namespace CryptoPP;

const int N1 = 6;  //NUmber of secondary nodes
const int N2 = 6; //number of primary

#define long int64_t

struct Hub
{
	string mk;
	int id1[N1];
};

struct Sense
{
	int id2;
	string a;
	string b;

	int adj[N1] = {0}; //list of primary nodes adjacent to the secondary node
};

struct Relay
{
	int id1;
	int id2;
	string a;
	string b;
};

ostringstream oss;

int buffer;

string makeupper(string s)
{
	for(char& c : s)
		c = toupper(c);

	return s;
}

string randomNumber(int bits, int flag)
{
	string temp;

	oss.clear();
	oss.str("");
	Integer x;

    AutoSeededRandomPool prng;
    x.Randomize(prng, bits);

    if(flag)
    {
		oss << std::hex << x;
		temp = oss.str();
		temp = temp.substr(0, (bits/4)-1);
		temp = makeupper(temp);
		//storing the random integer in oss
		//taking substring to remove 'H'

		reverse(temp.begin(), temp.end());
		temp.resize(bits/4, '0');
		reverse(temp.begin(), temp.end());
		//padding with 0's
    }
	else
	{
		oss << std::dec << x;
		temp = oss.str();
		temp = makeupper(temp);
		//stroring the decimal number
	}

	return temp;
}

//code for SHA1 hash
string generateHash(string source)
{
	SHA1 hash;
	byte digest[CryptoPP::SHA1::DIGESTSIZE];
	hash.CalculateDigest(digest, (const byte*)source.c_str(), source.size());
	string output;
	HexEncoder encoder;
	StringSink test = CryptoPP::StringSink(output);
	encoder.Attach(new CryptoPP::StringSink(output));
	encoder.Put(digest, sizeof(digest));
	encoder.MessageEnd();
	return output;
 }

//xor of two numbers
 //result in b
 string exor(string a, string b)
{
	reverse(a.begin(), a.end());
	a.resize(40, '0');
	reverse(a.begin(), a.end());

	reverse(b.begin(), b.end());
	b.resize(40, '0');
	reverse(b.begin(), b.end());

	for(int i = 0; i < 40; ++i)
	{
		int bd = (b[i] <= '9' ? b[i] - '0' : b[i] - 'A' + 10);
		int ad = (a[i] <= '9' ? a[i] - '0' : a[i] - 'A' + 10);
		bd ^= ad;
		b[i] = (bd <= 9 ? bd + '0' : bd + 'A' - 10);
	}
	return b;
}

int main()
{
	//INTIALIZATION PHASE

	//create the hub node
	Hub contNode;

	contNode.mk = randomNumber(160, 1);
	// cout << contNode.mk << endl << endl;

	//END INTIALIZATION PHASE

	//REGISTRATION PHASE

	//creating the second level (secondary)
	Sense secNodes[N2];
	//creating the first level nodes (primary)
	Relay priNodes[N1];

	//specifying the adjacent nodes
	for(int i = 0; i < 4; i++)
		secNodes[0].adj[i] = 1;

	secNodes[1].adj[0] = 1;
	secNodes[1].adj[4] = 1;

	secNodes[2].adj[3] = 1;
	secNodes[2].adj[5] = 1;

	secNodes[3].adj[4] = 1;

	secNodes[4].adj[5] = 1;

	for(int i = 0; i < 3; i++)
		secNodes[5].adj[i] = 1;
	//done specifyinh

	//store information into each primry and secondary node
	string k; //random number
	string input; //input to the hash

	for(int i=0; i<N2; i++)
	{
		secNodes[i].id2 = i; //assigning id

		k = randomNumber(160, 1);

		//a = id ^ h( Mk HN || k )
		input = contNode.mk + k;
		secNodes[i].a = exor(to_string(secNodes[i].id2), generateHash(input));

		//b = Mk HN  ^ a N ^ k N .
		string temp;
		temp = exor(secNodes[i].a, k);
		secNodes[i].b = exor(contNode.mk, temp);

		//storing into the primary node
		priNodes[i].id1 = i; //id of the primary node
		priNodes[i].id2 = i; //id of the secondary node
		priNodes[i].a = secNodes[i].a; // 'a' of secondary node
		priNodes[i].b = secNodes[i].b; //'b' of secondary node

		contNode.id1[i] = i; //storing id's of the primary nodes in the controller
	}

	//END REGISTRATION PHASE

	//AUTHENTICATION PHASE

	//CHoosing the second-level node and resizing it for hashing later on
	string str2 = randomNumber(160, 0); //str2 contains id of second-level node in string formt
	int rid = (int) (str2[4] - '0');
	rid = rid % 5; //id of the node transmitting message
	str2 = to_string(rid);
	reverse(str2.begin(), str2.end());
	str2.resize(40, '0');
	reverse(str2.begin(), str2.end());


	int prim; //id of primary node we are sending the message too
	
	//just hoosing the closest one
	for (int i = 0; i < N1; ++i)
	{
		if(secNodes[rid].adj[i])
		{
			prim = i;
			break;
		}
	}

	//padding prim
	string str1 = to_string(prim);
	reverse(str1.begin(), str1.end());
	str1.resize(40, '0');
	reverse(str1.begin(), str1.end());

	//STEP-1	
	string r = randomNumber(160, 1); //random number

	string t = randomNumber(160, 1); //timestamp, generated by the device, mimicking behaviour by making it a random number

	//str2 is id of sensor node
	string x = exor(str2, secNodes[rid].a); //x = a ^ id

	string y = exor(r, x); //y = x  ^ r  

	input = exor(str2, t) + r;
	string tid = generateHash(input); //temporary id; tid = h ( (id ^ t) , r )


	//STEP-2
	//checking if the primary node we sent information stored in hub node or not
	int flag1 = 0;
	int flag2 = 0;
	for (int i = 0; i < N1; ++i)
	{
		if(prim == contNode.id1[i])
		{
			flag1 = 1;
			break;
		}
	}

	//STEP-3
	//following used for fututre calculations
	string k1; 
	string x1; 
	string r1; 
	string id1;

	string tid1;

	if(flag1)
	{
		k1 = exor(contNode.mk, exor(secNodes[rid].a, secNodes[rid].b)); //k1 = k HN ^ a N ^ b N

		x1 = generateHash(contNode.mk + k1); //x1 = h ( k HN || k ∗ N )

		id1 = exor(secNodes[rid].a, x1); //id1 = x1  ^ a N

		r1 = exor(y, x1); //r1 = x1 ^ y N 

		input = exor(t, id1) + r1;
		tid1 = generateHash(input); //tid1 = h ( id1 ^ t , r1)

		//checking transaction id
		if(tid == tid1)
			flag2 = 1;
	}
	else
		cout << "\nMessage sent to invalid primary node\n";

	//used for future calculations
	string f;
	string alpha;
	string gamma;

	string k2; //new random number

	//generates new a and b
	string a1;
	string b1;

	string eta;
	string myu;

	string beta; //computed using x, r, f, eta, myu

	string sk; //session key
	
	//checks if the transaction is valid
	if(flag2)
	{
		// cout << "\nHI\n";

		f = randomNumber(160, 1);
		alpha = exor(x, f); //α = x N ^ f N
		gamma = exor(r, f); //γ = r N ^ f N

		k2 = randomNumber(160,1);
		a1 = exor(str2, generateHash(contNode.mk + k2)); //a1 = id N ^ h ( k HN || k2)

		input = exor(a1, k2);
		b1 = exor(contNode.mk, input); //b1 = k HN ^ a1 ^ k2

		eta = exor(gamma, a1); //eta = gamma ^ a1
		myu = exor(gamma, b1); //myu = gamma ^ b1

		beta = generateHash(x + r + f + eta + myu); //beta = h ( x N || r N || f N || eta || myu)

		sk = generateHash(str2 + r + f + x); //sk = h ( id N || r N || f N || x N )
	}
	else
		cout << "\nTransaction is invalid\n";

	string f1 = exor(x, alpha); //f1 = x N ^ α .

	string beta1 = generateHash(x + r + f1 + eta + myu); //beta1 = h ( x N || r N || f1 || η || μ )

	string sk1; //session key 1

	if(beta == beta1)
	{
		gamma = exor(r, f); //γ = r N ^ f N

		a1 = exor(gamma, eta); //a1 = gamma ^ eta

		b1 = exor(gamma, myu); //b1 = gamma ^ myu

		sk1 = generateHash(str2 + r + f + x); //sk1 = h ( id N || r N || f N || x N )

		//updating concerned values
		secNodes[rid].a = a1;
		secNodes[rid].b = b1;
		priNodes[prim].a = secNodes[rid].a;
		priNodes[prim].b = secNodes[rid].b;

		cout << "SUccessful transaction\n";
	}
	else
		cout << "\nUsed to verify corresponding beta values\n";
	return 0;
}
